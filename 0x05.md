# 实验五 基于 Scapy 编写端口扫描器

## 实验目的

- 掌握网络扫描之端口状态探测的基本原理

## 实验环境

- python + [scapy](https://scapy.net/)
- 安装ufw以控制端口状态

```bash
#安装ufw
sudo apt install ufw
#允许端口访问
sudo ufw enable && ufw allow portno/tcp(udp)
#端口过滤状态
sudo ufw enable && ufw deny portno/tcp(udp)
#端口关闭状态
sudo ufw disable
```

* 安装dnsmasq服务以开启udp端口

```bash
sudo apt install dnsmasq
```

## 实验要求

- [x] 完成以下扫描技术的编程实现

- TCP connect scan / TCP stealth scan
- TCP Xmas scan / TCP fin scan / TCP null scan
- UDP scan

- [x] 上述每种扫描技术的实现测试均需要测试端口状态为：`开放`、`关闭` 和 `过滤` 状态时的程序执行结果

- [x] 提供每一次扫描测试的抓包结果并分析与课本中的扫描方法原理是否相符？如果不同，试分析原因；
- [x] 在实验报告中详细说明实验网络环境拓扑、被测试 IP 的端口状态是如何模拟的
- [x] （可选）复刻 `nmap` 的上述扫描技术实现的命令行参数开关（每种扫描测试一种状态，且后面专门用nmap进行了扫描实验）



## 实验相关知识总结

:one:**TCP Connect 扫描**

​	这种扫描方式可以使用 Connect()调用，使用最基本的 TCP 三次握手链接建立机制，建立一个链接到目标主机的特定端口上。首先发送一个 SYN 数据包到目标主机的特定端口上，接着我们可以通过接收包的情况对端口的状态进行判断：如果接收到的是一个 SYN/ACK 数据包，则说明端口是开放状态的；如果接收到的是一个 RST/ACK 数据包，通常意味着端口是关闭的并且链接将会被重置；而如果目标主机没有任何响应或者返回其他拒绝反馈报文则意味着目标主机的端口处于过滤状态。

​	其中若接收到 SYN/ACK 数据包（即检测到端口是开启的），便发送一个 ACK 确认包到目标主机，这样便完成了三次握手连接机制。成功后再发送RST数据包终止连接。

​	这个方式属于开放式扫描，优点是稳定可靠，不需要特殊的权限，但是服务器日志会记录下大量密集的连接和错误记录，也容易被防火墙发现和屏蔽。

![0x05_1](/img/0x05_1.png)

:two:**TCP stealth scan**

​	这种扫描属于半开放扫描，他和TCP Connect的唯一区别，就是当服务器向主机发来SYN/ACK包时，不完成三次握手，直接发送RST包取消连接。这样做的好处是大多数主机并不会留下“失败”的连接记录，隐蔽性更好。

:three:**TCP 隐蔽扫描**

> 包括TCP Xmas scan / TCP fin scan / TCP null scan等，主要都用来确认目标主机端口是否为关闭，与其他几种方式联合使用来增加端口扫描可靠性，以确定端口到底是被防火墙拦截还是确实关闭了

**TCP FIN扫描**

| 序号 | 通信方向 |      流程1      |          流程2          |
| :--: | :------: | :-------------: | :---------------------: |
|  1   |   C->S   | TCP FIN+Port(n) |     TCP FIN+Port(n)     |
|  2   |   S->C   |       RST       | 无响应/其他拒绝反馈报文 |
|      | 状态推断 |      关闭       |    开放/关闭/被过滤     |

​	该扫描仅发送FIN包，优点是FIN数据包能够通过只检测SYN包的包过滤器，隐蔽性比SYN扫描更高；缺点是需要自己构造数据包，需要管理员权限

**TCP Xmas扫描**

| 序号 | 通信方向 |                 流程1                  |                 流程2                  |
| :--: | :------: | :------------------------------------: | :------------------------------------: |
|  1   |   C->S   | TCP<br />FIN(1),PUSH(1),URG(1)+Port(n) | TCP<br />FIN(1),PUSH(1),URG(1)+Port(n) |
|  2   |   S->C   |                  RST                   |        无响应/其他拒绝反馈报文         |
|      | 状态推断 |                  关闭                  |            开放/关闭/被过滤            |

**TCP Null扫描**

| 序号 | 通信方向 |                 流程1                  |                 流程2                  |
| :--: | :------: | :------------------------------------: | :------------------------------------: |
|  1   |   C->S   | TCP<br />FIN(0),PUSH(0),URG(0)+Port(n) | TCP<br />FIN(0),PUSH(0),URG(0)+Port(n) |
|  2   |   S->C   |                  RST                   |        无响应/其他拒绝反馈报文         |
|      | 状态推断 |                  关闭                  |            开放/关闭/被过滤            |

​	这两个扫描类似，前者将报文头的FIN URG和PUSH标记都设为1，后者则全设置为0。优点是隐蔽性好；缺点是需要自己构造数据包，需要管理员权限

:four:UDP 扫描

​	UDP 是一个无链接的协议，当我们向目标主机的 UDP 端口发送数据，我们并不能收到一个开放端口的确认信息,或是关闭端口的错误信息。可是，在大多数情况下，当向一个未开放的 UDP 端口发送数据时，其主机就会返回一个 ICMP 不可到达(ICMP_PORT_UNREACHABLE)的错误，因此大多数 UDP 端口扫描的方法就是向各个被扫描的 UDP 端口发送零字节的 UDP 数据包，如果收到一个 ICMP 不可到达的回应，那么则认为这个端口是关闭的,反之则认为是开放的。

​	但是如果目标主机安装有防火墙或其它可以过滤数据包的软硬件，那我们发出 UDP 数据包后，将可能得不到任何回应，我们将会见到所有的被扫描端口都是开放的。

​	这就是它的缺点，UDP 是不可靠的，UDP 数据包和 ICMP 错误报文都不保证到达；且 ICMP 错误消息发送效率是有限的，故而扫描缓慢；还有就是非超级用户无法直接读取端口访问错误。

![0x05_2](/img/0x05_2.png)



## 实验过程

### 网络拓扑

> 同第四章相似，victim为受害者，attacker为攻击者，gateway为网关

![0x05_3](/img/0x05_3.png)

### Scapy相关基础

```python
# 导入模块
from scapy.all import *
# 查看包信息
pkt = IP(dst="")
ls(pkt)
pkt.show()
summary(pkt)
# 发送数据包
send(pkt)  # 发送第三层数据包，但不会受到返回的结果。
sr(pkt)  # 发送第三层数据包，返回两个结果，分别是接收到响应的数据包和未收到响应的数据包。
sr1(pkt)  # 发送第三层数据包，仅仅返回接收到响应的数据包。
sendp(pkt)  # 发送第二层数据包。
srp(pkt)  # 发送第二层数据包，并等待响应。
srp1(pkt)  # 发送第二层数据包，并返回响应的数据包
# 监听网卡
sniff(iface="wlan1",count=100,filter="tcp")
# 应用：简单的SYN端口扫描 （测试中）
pkt = IP("...")/TCP(dport=[n for n in range(22, 3389)], flags="S")
ans, uans = sr(pkt)
ans.summary() # flag为SA表示开放，RA表示关闭
```

### 端口状态模拟

- 关闭状态：对应端口没有开启监听, 防火墙没有开启。

  ```bash
  sudo ufw disable
  ```

- 开启状态：对应端口开启监听: apache2基于TCP, 在80端口提供服务; DNS服务基于UDP,在53端口提供服务。防火墙处于关闭状态。

  ```bash
  sudo systemctl start apache2 # port 80
  sudo systemctl start dnsmasq # port 53
  ```

- 过滤状态：对应端口开启监听, 防火墙开启。

  ```bash
  sudo ufw enable && ufw deny 80/tcp
  sudo ufw enable && ufw deny 53/udp
  ```

  此时，被扫描主机的初始状态为：

![](/img/0x05_4.png)

---

​	**让我们开始实验，以下连续三幅图片分别为** ：`攻击者主机运行代码测试的结果`，`靶机抓包的结果`，`攻击者主机使用nmap复刻的结果`

#### TCP connect scan

[code](https://github.com/CUCCS/2021-ns-public-Tbc-tang/blob/chap0x05/code/tcp_connect_scan.py)

* 端口关闭

![0x05_5](/img/0x05_5.png)

![0x05_6](/img/0x05_6.png)

![0x05_7](/img/0x05_7.png)

* 端口开启

![0x05_8](/img/0x05_8.png)

![](/img/0x05_a.png)

![0x05_9](/img/0x05_9.png)

* 端口被过滤

![0x05_b](/img/0x05_b.png)

![0x05_c](/img/0x05_c.png)

![0x05_d](/img/0x05_d.png)

> 注意在端口被过滤时，使用nmap命令需要使用超级账户权限
>
> 特别提醒，如果按照我的实验顺序进行实验，你还需要用`systemctl stop apache2`+`ufw disable`命令关闭端口与监控

#### TCP stealth scan

[code](https://github.com/CUCCS/2021-ns-public-Tbc-tang/blob/chap0x05/code/tcp_stealth_scan.py)

* 端口关闭

![0x05_e](/img/0x05_e.png)

![0x05_f](/img/0x05_f.png)

![0x05_10](/img/0x05_10.png)

* 端口开启

![0x05_11](/img/0x05_11.png)

![0x05_12](/img/0x05_12.png)

![0x05_13](/img/0x05_13.png)

* 端口被过滤

![0x05_14](/img/0x05_14.png)

![0x05_15](/img/0x05_15.png)

![0x05_16](/img/0x05_16.png)

#### TCP Xmas scan

[code](https://github.com/CUCCS/2021-ns-public-Tbc-tang/blob/chap0x05/code/tcp_xmas_scan.py)

* 端口关闭

![0x05_17](/img/0x05_17.png)

![0x05_18](/img/0x05_18.png)

![0x05_19](/img/0x05_19.png)

* 端口开启

![0x05_20](/img/0x05_20.png)

![0x05_21](/img/0x05_21.png)

![0x05_22](/img/0x05_22.png)

* 端口过滤

![0x05_23](/img/0x05_23.png)

![0x05_25](/img/0x05_25.png)

![0x05_24](/img/0x05_24.png)

> 这里我特别在nmap之后截了wireshark上的图，可以看到，我们构造的脚本扫描原理和nmap其实是一样的

#### TCP fin scan

[code](https://github.com/CUCCS/2021-ns-public-Tbc-tang/blob/chap0x05/code/tcp_fin_scan.py)

* 端口关闭

![0x05_26](/img/0x05_26.png)

![0x05_27](/img/0x05_27.png)

![0x05_28](/img/0x05_28.png)

* 端口开启

![0x05_29](/img/0x05_29.png)

![0x05_30](/img/0x05_30.png)

![0x05_31](/img/0x05_31.png)

* 端口过滤

![0x05_32](/img/0x05_32.png)

![0x05_33](/img/0x05_33.png)

![0x05_34](/img/0x05_34.png)

#### TCP null scan

[code](https://github.com/CUCCS/2021-ns-public-Tbc-tang/blob/chap0x05/code/tcp_null_scan.py)

* 端口关闭

![0x05_35](/img/0x05_35.png)

![0x05_36](/img/0x05_36.png)

![0x05_37](/img/0x05_37.png)

* 端口开启

![0x05_38](/img/0x05_38.png)

![0x05_39](/img/0x05_39.png)

![0x05_40](/img/0x05_40.png)

* 端口过滤

![0x05_41](/img/0x05_41.png)

![0x05_42](/img/0x05_42.png)

![0x05_43](/img/0x05_43.png)

#### UDP scan

[code](https://github.com/CUCCS/2021-ns-public-Tbc-tang/blob/chap0x05/code/udp_scan.py)

* 端口关闭

![0x05_44](/img/0x05_44.png)

![0x05_45](/img/0x05_45.png)

![0x05_46](/img/0x05_46.png)

* 端口开启

![0x05_47](/img/0x05_47.png)

![0x05_48](/img/0x05_48.png)

![](/img/0x05_49.png)

* 端口过滤

![0x05_50](/img/0x05_50.png)

![0x05_51](/img/0x05_51.png)

![0x05_52](/img/0x05_52.png)

- 提供每一次扫描测试的抓包结果并分析与课本中的扫描方法原理是否相符？如果不同，试分析原因；

  抓包以截图形式提供在每次扫描结果中，我们构造的脚本与nmap扫描的过程在wireshark中完全相符。产看了一下[nmap文档](https://nmap.org/book/)，原理是相同的。但是实操中nmap要快不少。

---

#### 参考链接

[nmap命令参考](https://blog.csdn.net/weixin_39646831/article/details/111340740)

[代码参考](https://github.com/CUCCS/2020-ns-public-LyuLumos/tree/ch0x05/ch0x05#%E7%AB%AF%E5%8F%A3%E7%8A%B6%E6%80%81%E6%A8%A1%E6%8B%9F)

[课本连接](https://c4pr1c3.gitee.io/cuc-ns/chap0x05/main.html)

